# Дистанционный мониторинг нагрузки процессов

## Описание

Реализация набора программ на языке **C** (без использования сторонних библиотек):

- **Сервер** – Для предоставления информации о нагрузке CPU и активных PID'ах
- **Клиент** – Отправление запросов на сервер
- **Утилита сохранения журнала** – сохраняет журнал сервера из shared memory в файл

Все компоненты работают через стандартные средства POSIX и Linux API.

---

## Структура

```
project/
├── main_server.c
├── server.c
├── server.h
├── main_client.c
├── client.c
├── client.h
├── logger_utility.c
├── Makefile
├── sudoGdb  ----> в рамках текущего репозитория не применяется, сохранено для личного пользования
└── README.md
```

---

## Функциональность

### 1. Сервер

Сервер состоит из:
- Региона **shared memory**, используемого как **журнал логов**
- **5 worker-процессов**, слушающих заданные порты по UDP

#### Поддерживаемые запросы:

| Тип запроса | Описание                                                            |
| ----------- | ------------------------------------------------------------------- |
| `"show"`    | Возвращает список всех активных PID'ов на сервере                   |
| `"%d"`      | Возвращает %CPU процесса с указанным PID                            |
| Невалидный  | Ответ: `"invalid"`, запись в журнал: `"DATE TIME: invalid request"` |

---

### 2. Клиент

Клиент поддерживает **три режима работы**:

#### Режим 1: Получение списка всех PID'ов

```cpp
void pids(Client client, const char* ip, int port) {
    InitClient(&client, ip, port);
    client.GetAllPids(&client);
}
```

- Отправляет команду `"show"` на указанный порт
- Принимает ответ и выводит список PID'ов (на данный момент только часть, на сколько хватит места в буфере)

#### Режим 2: Запрос нагрузки CPU по PID
```cpp
void pid(Client client, const char* ip, int port, int pidn) {
    InitClient(&client, ip, port);
    client.GetCpuUsageByPid(&client, pidn);
}
```

- Запрос у сервера текущей нагрузки соответствующего PID
- Получает и выводит процент CPU или `"not found"`

#### Режим 3: Фаззинг портов случайными PID
```cpp
void fuzzing(Client client, const char* ip, int* ports, int portsCount) {
    if(portsCount > 1) {
        InitClient(&client, ip, ports[0]);
        client.FuzzServer(&client, ports, portsCount);
    }
}
```

- Бомбардировка сервера случайными числами в качестве pid на все указанные порты
- Работает до завершения (`Ctrl+C` / `kill`)

---

### 3. Инструмент сохранения журнала

```bash
./logger_utility
```

- Сохраняет содержимое shared memory в указанный файл
- Запускается в той же среде, где запущен сервер

---
## Описание сборочного процесса

Сборка выполняется с аргументами `-Wall -Wextra -Wstrict-prototypes -Wdeclaration-after-statement -Werror -O3 -D_DEFAULT_SOURCE
`

Отдельно для сервера и клиента добавляется `-Wmissing-declarations`

Опционально при сборке можно добавить отладочные символы добавив аргументы `-ggdb -g3` для этого перед запуском процесса сборки следует задать переменную окружения _DEBUG_: `DEBUG=1 make <something>`

Также используются:

- `-pthread` – для работы с семафорами
- `-lrt` – для работы с shared memory

---

## Сборка

```bash
make <something>
```

something ∊ [all, server, client, logger_utility]

---

## Использование

### Запуск сервера:
```bash
./server
```

Проверить работу сервера можно командами:

```bash
echo "696969" | nc -uv 127.0.0.1 27015
echo -n "show" | nc -uv 127.0.0.1 27015
ss -plun | grep server
```

### Запуск клиента:

Для запуска одного из режимов следует закомментировать вызовы других в функции **int main()** в файле **main_client.cpp**,
выполнить сборку `make client` и запустить полученный исполняемый файл

```bash
./client
```

***Если требуется, можно изменить опции запуска в функции main***

### Сохранение журнала:

Указание файла для сохранения, выполняется в файле logger_utility.cpp


```bash
./logger_utility
```

---
